[{
  "_id": "65cadf2d8fb422ed7b83a08b",
  "workshopGroupId": "idiomatic-reactive-data-streams",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-13T03:17:01.473Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Embracing Idiomatic Reactive Data Streams with Angular and RxJS\"},{\"blockId\":\"n4wmmnwvper\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/Idiomatic_Reactive_Data_Streams.webp\\\",\\\"title\\\":\\\"Test\\\"}\"},{\"blockId\":\"edydyj2dje\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to Angular and Reactive Programming with RxJS\",\"savedAction\":\"h1\"},{\"blockId\":\"p9ehdykb5w\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Welcome to our comprehensive workshop designed to introduce and deepen your understanding of idiomatic reactive data streams utilizing Angular and RxJS. Angular, a platform and framework for building single-page client applications, incorporates a reactive programming style that is both robust and scalable. Coupled with RxJS, a library for asynchronous programming and stream manipulation, Angular provides a powerful suite of tools for modern web development.\"},{\"blockId\":\"wav5filoh3\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"The Foundation of Angular: MVVM Architecture\",\"savedAction\":\"h2\"},{\"blockId\":\"4ibjylwh4gt\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Angular's architectural approach, inspired by the Model-View-ViewModel (MVVM) pattern, facilitates a clear separation of concerns within applications. This architecture not only promotes maintainability but also enhances the scalability of applications by dividing the application logic, user interface, and data model. Angular's commitment to reactivity ensures that your applications remain responsive and performant, adapting seamlessly to user interactions and data changes.\"},{\"blockId\":\"c0s0ptychzo\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"RxJS: The Backbone of Angular's Reactivity\",\"savedAction\":\"h2\"},{\"blockId\":\"2o38xsmbh6e\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"RxJS plays a pivotal role in Angular's ecosystem by offering a comprehensive set of operators and functions to manage asynchronous events and data streams. The library's capabilities allow developers to elegantly handle complex data flows, orchestrate asynchronous operations, and implement sophisticated event handling mechanisms, all within a reactive paradigm.\"},{\"blockId\":\"a82j13ng7v4\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Getting Started: Initial Exploration\"},{\"blockId\":\"bzqtpetfz9j\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"In the initial phase of our workshop, specifically within the 1-lab-start branch, we introduce a foundational example through the AppComponent. This component serves as the initial touchpoint, demonstrating Angular's reactive capabilities in a simplified context.\"},{\"blockId\":\"s0nxkc2iojd\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"// app.component.ts\\nimport { Component } from '@angular/core';\\nimport { CommonModule } from '@angular/common';\\n\\n@Component({\\n  selector: 'app-root',\\n  standalone: true,\\n  imports: [CommonModule],\\n  template: `\\n  <h1>{{ title }}</h1>\\n  `,\\n})\\nexport class AppComponent {\\n  title = 'Idiomatic Reactive Data Streams';\\n}\\n\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"91jt8alhj6w\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Delving into Reactive Programming Principles\",\"savedAction\":\"h2\"},{\"blockId\":\"2lj3fkjfnvu\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"The journey begins with understanding the basics of Angular's template syntax and its integration with reactive programming concepts. The simple data binding showcased here paves the way for more complex reactive interactions, which will be explored as we progress through the workshop.\"},{\"blockId\":\"9b71ksgv9ff\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Key Insights and Best Practices\",\"savedAction\":\"h2\"},{\"blockId\":\"pfac2v8zkyq\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li><b>Leveraging MVVM:</b> Angular's adoption of the MVVM pattern is critical for structuring applications that are both manageable and scalable. Embracing this pattern will facilitate better state management and UI/data separation.<br><br></li><li><b>Mastering RxJS: </b>Familiarity with RxJS operators is essential for effective reactive programming. Operators such as map, filter, and combineLatest are fundamental tools for data stream manipulation.<br><br></li><li><b>Utilizing Async Pipe: </b>The async pipe is a cornerstone of Angular's reactivity, simplifying subscription management and preventing memory leaks by automatically subscribing to and unsubscribing from Observables.</li></ul>\"},{\"blockId\":\"ggs0zfn0rnt\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"This workshop is designed to equip you with the knowledge and skills necessary to harness the full potential of Angular and RxJS in building reactive applications. As we move forward, each lab will build upon the last, incrementally increasing in complexity and introducing more advanced concepts and techniques.\"},{\"blockId\":\"nax75ko9whm\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"We look forward to guiding you through this journey into idiomatic reactive programming with Angular and RxJS.\"},{\"blockId\":\"db1omzltrke\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<i>This workshop is an invitation to explore the reactive programming paradigm within the Angular framework, offering both foundational knowledge and advanced techniques. We encourage an inquisitive approach, experimentation, and continuous learning as key components of your development journey.</i><div><br></div><div><b>Reference Material:</b><br><div><ul><li><a href=\\\"https://github.com/Ba5ik7/workshop-reactive-data-streams/tree/1-lab-complete\\\">Workshop Lab Repo</a></li></ul><div>After cloning the repo checkout the branch <b>1-lab-start.</b></div></div></div>\"}]",
  "__v": 0
},
{
  "_id": "65caefa58fb422ed7b83a0a8",
  "workshopGroupId": "idiomatic-reactive-data-streams",
  "name": "Page 2",
  "sortId": 1,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-13T04:27:17.638Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Introduction to RxJS Observables and Async Pipe\"},{\"blockId\":\"u1sy9msbjrf\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/1.a-lab.webp\\\",\\\"title\\\":\\\"DALL-E\\\"}\"},{\"blockId\":\"rs91jq2znif\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:&nbsp;</b><span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>Participants will learn to create basic observables with RxJS and utilize the async pipe in Angular for subscribing to these observables in templates.</i></span>\"},{\"blockId\":\"cvzzgfrxodf\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to RxJS Observables\"},{\"blockId\":\"42j7w7r7cdr\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Observables are the foundational building blocks in RxJS, representing data streams that can emit multiple values over time. In this lab, we'll explore two primary ways to create observables:<div><br><div><ul><li><code class=\\\"inline-code-example\\\">of</code> <b>Function</b>: Creates an observable that emits the values you provide as arguments, then completes.<br><br></li><li><code class=\\\"inline-code-example\\\">from</code> <b>Function</b>: Converts various other objects and data types into observables. For example, it can convert an array, a promise, or an iterable into an observable.<br><br></li></ul></div><div></div></div>\"},{\"blockId\":\"1j2kykytf3w\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Utilizing the Async Pipe in Angular\",\"savedAction\":\"h2\"},{\"blockId\":\"jxefpkdu8fh\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"The async pipe is a powerful Angular feature that allows you to subscribe to observables directly from your templates. It handles subscription management automatically, subscribing to the observable when the component loads and unsubscribing when the component is destroyed, thus preventing potential memory leaks.<div><br></div>\"},{\"blockId\":\"bn17ytyjdn5\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise: Creating and Displaying Observables\"},{\"blockId\":\"xomdw5iseo\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Create Simple Observables:&nbsp;</b><div><ul><li>Use the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">of</code> function to create an observable from the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">title</code> string. This observable will emit a single value - the title string.<br><br></li><li>Use the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">from</code> function to create an observable from the same <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">title</code> string. This will create an observable that emits each character of the string individually.</li></ul><div><br><b>Modify the Component Template:</b><br><div><ul><li>Update the component template to display the values emitted by these observables using the async pipe.</li></ul></div></div></div>\"},{\"blockId\":\"655hgmte1sk\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"\"},{\"blockId\":\"s3dz0opdhb8\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"m7e2naws8mn\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"title$ = of(this.title);\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"f79shc7h60t\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<div style=\\\"text-align: left;\\\"><ul><li>This line creates an observable that emits the value of this.title and then completes.</li></ul></div>\"},{\"blockId\":\"99347sguact\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"titles$ = from(this.title);\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"phqm0nve3xn\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>This line creates an observable that emits each character of this.title string as individual emissions.</li></ul>\"},{\"blockId\":\"vx4t8jmfn5s\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Updating the Template:\",\"savedAction\":\"h2\"},{\"blockId\":\"ljitw8wrve\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Use the async pipe to subscribe to these observables in the template and display the emitted values.</li></ul>\"},{\"blockId\":\"8ghkin512b6\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"<h1>{{ title$ | async }}</h1>\\n<h1>{{ titles$ | async }}</h1>\",\"savedAction\":\"xml\"},{\"blockId\":\"3rodvpwsxmx\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"fnq22h0xqew\",\"sortIndex\":19,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Discuss the difference between of and from and when to use each.<br><br></li><li>Explore how the async pipe simplifies observables' subscription management in Angular templates.</li></ul><div><br></div>\"},{\"blockId\":\"ktft9486vrs\",\"sortIndex\":20,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"v917tofx0is\",\"sortIndex\":21,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Experiment with transforming the data emitted by the observables using RxJS operators like map or filter before displaying them in the template.<br><br></li><li>Investigate the behavior of the async pipe when used with different types of observables and data streams.</li></ul>\"},{\"blockId\":\"qo8wmtf6sy\",\"sortIndex\":22,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab provides a practical introduction to the creation and use of observables in Angular applications, laying the groundwork for more complex reactive programming techniques in subsequent modules.\"},{\"blockId\":\"6iqf7gkbmzw\",\"sortIndex\":23,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"\"}]",
  "__v": 0
},
{
  "_id": "65cb02798fb422ed7b83a136",
  "workshopGroupId": "idiomatic-reactive-data-streams",
  "name": "Page 3",
  "sortId": 2,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-13T05:47:37.083Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Enhancing Observables with RxJS Operators\"},{\"blockId\":\"rpnxyik09ti\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/1.b-lab.webp\\\",\\\"title\\\":\\\"DALL-E\\\"}\"},{\"blockId\":\"z72h3ggwiw\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:</b>&nbsp;<span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>Participants will gain hands-on experience in applying RxJS operators to transform and debug observables, showcasing the versatility and power of reactive programming within Angular applications.</i></span>\"},{\"blockId\":\"powgf1ulaso\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to RxJS Operators\"},{\"blockId\":\"zilwwzt45w\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<div><br></div><div>RxJS operators are functions that allow you to manipulate the items emitted by observables in various ways, such as transforming values, filtering streams, or combining multiple observables. In this lab, we focus on three operators:</div><div><br></div><div><ul><li><code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code> <b>Operator</b>: Transforms each value emitted by an observable by applying a function to each item.<br><br></li><li><code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">tap</code> <b>Operator</b>: Performs a side effect for every emission on the source Observable but returns an Observable that is identical to the source.<br><br></li><li><code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">toArray</code> <b>Operator</b>: Collects all source emissions and emits them as an array when the source completes.</li></ul></div>\"},{\"blockId\":\"8i4gk8xlpi8\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise: Transforming and Debugging Data Streams\",\"savedAction\":\"h2\"},{\"blockId\":\"bcfx5728c9\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>1) Applying map to Transform Values:</b>\"},{\"blockId\":\"ofr3wsebrkl\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<span style=\\\"letter-spacing: 0.249999px;\\\"><b>Transform Data with <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code>:</b></span><div><ul><li><span style=\\\"letter-spacing: 0.249999px;\\\">Apply the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code> operator to transform the title string to uppercase.</span></li></ul><div><span style=\\\"letter-spacing: 0.249999px;\\\"><b>Debugging with <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">tap</code>:</b></span></div></div><div><ul><li><span style=\\\"letter-spacing: 0.249999px;\\\">Use the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">tap</code> operator to log each character emitted by the observable created with from.</span></li></ul><div><span style=\\\"letter-spacing: 0.249999px;\\\"><b>Aggregating Stream Values with <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">toArray</code>:</b></span></div></div><div><ul><li><span style=\\\"letter-spacing: 0.249999px;\\\">Combine the individual characters emitted back into a single string using <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">toArray</code> and <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code>.</span></li></ul></div>\"},{\"blockId\":\"089t382qbmdn\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"9cabjnb0brh\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"title$ = of(this.title).pipe(\\n  map((title) => title.toUpperCase())\\n);\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"6qbhw0tfzts\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>2) Using <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">tap</code> for Side Effects:</b>\"},{\"blockId\":\"g434ycn537\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"titles$ = from(this.title).pipe(\\n  tap(console.log), // Logs each character emitted by the observable\\n  toArray(), // Collects all emissions into an array\\n  map((titles) => titles.join('')) // Joins the array elements into a string\\n);\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"hqusgkzkdpj\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>3) Updating the Component Template:<br><ul><li>Display the transformed data in the template using the async pipe.</li></ul></b>\"},{\"blockId\":\"ew4syky89pc\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"<h1>{{ title$ | async }}</h1>\\n<h1>{{ titles$ | async }}</h1>\",\"savedAction\":\"xml\"},{\"blockId\":\"8hda77veff8\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"91l7xuujhif\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Explore how <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code> can be used to perform any operation on the items emitted by an observable.<br><br></li><li>Discuss the utility of <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">tap</code> for debugging observables without affecting the data stream.<br><br></li><li>Understand the use of toArray in aggregating stream emissions and its implications on observable completion.</li></ul>\"},{\"blockId\":\"fj6zejrrqcv\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"8qhvirhfc1\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Experiment with other RxJS operators to perform different transformations and manipulations on data streams.<br><br></li><li>Consider scenarios where aggregating stream values would be useful in real-world applications.</li></ul>\"},{\"blockId\":\"uk1svqhe4v8\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab emphasizes the flexibility and power of RxJS within Angular applications, providing participants with practical experience in data stream manipulation and debugging.\"}]",
  "__v": 0
},
{
  "_id": "65cb04ea8fb422ed7b83a13f",
  "workshopGroupId": "idiomatic-reactive-data-streams",
  "name": "Page 4",
  "sortId": 3,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-13T05:58:02.181Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Workshop Module: Combining Multiple Observables with combineLatest\"},{\"blockId\":\"shqinqy3ohe\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/1.c-lab.webp\\\",\\\"title\\\":\\\"DALLE\\\"}\"},{\"blockId\":\"lsaidvf4oi\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:&nbsp;</b><i style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\">Participants will learn to use the combineLatest function to combine multiple observables into one, demonstrating how to work with multiple streams of data reactively.</i>\"},{\"blockId\":\"ch7ck3cpsf\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to combineLatest\"},{\"blockId\":\"olllzppqro\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"combineLatest is an RxJS function that takes multiple observables as input and generates a new observable that emits an array of the latest values from each input observable whenever any input observable emits a value. This is particularly useful in scenarios where you need to perform operations or update the UI based on the latest values from multiple data sources.\"},{\"blockId\":\"tqbuk57csy\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise: Creating a Combined Data Model\",\"savedAction\":\"h2\"},{\"blockId\":\"p6p2azbap5\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Combine Observables:</b><div><ul><li>Use <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">combineLatest</code> to combine the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">title$</code> and <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">titles$</code> observables into a single observable stream.</li></ul><div><b>Map to a ViewModel:</b></div></div><div><ul><li>Apply the <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code> operator to transform the combined array of latest values into a single object, suitable for consumption by the component template.</li></ul></div>\"},{\"blockId\":\"pm0rwum32y\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"ixvn837okm\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>1) Combining Observables with combineLatest:</b>\"},{\"blockId\":\"xqz44znl5rs\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"viewModel$ = combineLatest([this.title$, this.titles$]).pipe(\\n  map(([title, titles]) => ({ title, titles }))\\n);\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"nlzaegmqbkt\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>2) Updating the Component Template:</b><div><ul><li>Use the Angular's structural directive *ngIf with the async pipe to unwrap the combined observable and access the title and titles properties.</li></ul></div>\"},{\"blockId\":\"o2fhnvmze9o\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"@if(viewModel$ | async as vm) {\\n  <h1>{{ vm.title }}</h1>\\n  <h2>{{ vm.titles }}</h2>\\n}\",\"savedAction\":\"xml\"},{\"blockId\":\"zblyjil7gbi\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"9peick20vlv\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Discuss the behavior of combineLatest and how it differs from other combination strategies like forkJoin or zip.<br><br></li><li>Explore the importance of mapping combined streams into view models to simplify template integration.</li></ul>\"},{\"blockId\":\"ad2sqccg0z\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"vt54h1jzzr\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Challenge participants to include additional observables in the combination, such as data from another service or user input streams.<br><br></li><li>Discuss strategies for handling errors and incomplete streams when using combineLatest.</li></ul>\"},{\"blockId\":\"ktzuc86b9ae\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab showcases the versatility of RxJS for managing complex data dependencies in Angular applications, providing participants with a practical understanding of combining and mapping multiple data streams.\"}]",
  "__v": 0
},
{
  "_id": "65cb06248fb422ed7b83a146",
  "workshopGroupId": "idiomatic-reactive-data-streams",
  "name": "Page 5",
  "sortId": 4,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-13T06:03:16.486Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Integrating Angular Services and Reactive State Management\"},{\"blockId\":\"495bn5ycfmt\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/1-lab-complete.webp\\\",\\\"title\\\":\\\"DALL-E\\\"}\"},{\"blockId\":\"0gv5jlbf1vh\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:</b>&nbsp;<i style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\">Participants will learn to integrate Angular services into components, use combineLatest to combine data streams from services, and update data reactively using BehaviorSubjects.</i>\"},{\"blockId\":\"ub6pgvjubb\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to Angular Services and BehaviorSubject\"},{\"blockId\":\"16wxwho7rss\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Angular services are singleton objects that provide a method to encapsulate and share logic, data, or functions across components. BehaviorSubject is a type of Subject in RxJS that requires an initial value and emits its current value to new subscribers. It's particularly useful for representing \\\"values over time\\\" in your application.\"},{\"blockId\":\"2vd7941f3ql\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise: Building a Reactive User Interface with Services\",\"savedAction\":\"h2\"},{\"blockId\":\"4xsu18onlx9\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Integrate ContentService:</b><div><ul><li><span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\">Inject ContentService into the AppComponent and use it to provide reactive data streams.</span></li></ul><div><span style=\\\"letter-spacing: 0.249999px;\\\"><b>Combine Service Data Streams:</b></span></div></div><div><ul><li><span style=\\\"letter-spacing: 0.249999px;\\\">Use combineLatest to combine multiple BehaviorSubjects from ContentService into a single observable stream.</span></li></ul><div><span style=\\\"letter-spacing: 0.249999px;\\\"><b>Reactive Data Updates:</b></span></div></div><div><ul><li><span style=\\\"letter-spacing: 0.249999px;\\\">Implement a method to update BehaviorSubject values within ContentService, reflecting changes reactively in the component.</span></li></ul></div>\"},{\"blockId\":\"pxgkacaeikb\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"0yoq84w0a97n\",\"sortIndex\":21,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"\"},{\"blockId\":\"8eamdkuqug\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>1) Injecting ContentService and Combining Streams:</b>\"},{\"blockId\":\"si1yt1jum69\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"contentService = inject(ContentService);\\n\\nviewModel$ = combineLatest([\\n  this.contentService.title$,\\n  this.contentService.titles$,\\n  this.contentService.body$\\n]).pipe(\\n  map(([title, titles, body]) => ({ title, titles, body }))\\n);\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"ai99uu10tlc\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>2) Updating the Component Template:</b><div><ul><li>Utilize the async pipe to manage the subscription to viewModel$, displaying the title, titles, and body in the component's template.<br><br></li><li>Add a button to trigger updates to the reactive data streams.</li></ul></div>\"},{\"blockId\":\"33unevz4wdc\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"<button (click)=\\\"updateValue()\\\">Update Title and Body values</button>\",\"savedAction\":\"xml\"},{\"blockId\":\"ag1lw5f14ve\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>3) Implementing BehaviorSubject in ContentService:</b><div><ul><li><b>BehaviorSubject Multicast Nature:&nbsp;</b><span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\">BehaviorSubject is a type of Subject in RxJS that can multicast, meaning it can emit the same value to multiple subscribers. This is particularly useful in scenarios where you need to ensure consistent state across different parts of your application that are all observing the same data source.<br><br></span></li><li><b>Benefits of asObservable():&nbsp;</b><span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\">When exposing BehaviorSubject from a service, it's a best practice to use asObservable() to convert it into an Observable. This approach encapsulates the subject, preventing external parts of the application from emitting new values to the subject directly, thus maintaining control over the data stream and ensuring the data integrity by adhering to the principle of least privilege.</span></li></ul></div>\"},{\"blockId\":\"6u1ujmlpokp\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"body = new BehaviorSubject<string>('BehaviorSubject: This is a type of subject, a special type of observable, that allows multicasting to multiple observers.');\\nbody$ = this.body.asObservable();\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"a9ieriqiez8\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<b>4) Demonstrating Reactive Updates:</b><div><ul><li>Emphasize that changes to title (used in of) are not reflected in the view, underscoring the completion behavior of <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">of</code>.<br><br></li><li>Show how updates to body via BehaviorSubject.next() are immediately reflected, demonstrating the reactive nature of BehaviorSubject.</li></ul></div>\"},{\"blockId\":\"2xy95nn0b7v\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"updateValue() {\\n  this.contentService.title = 'Unchanged Title'; // Attempt to update title\\n  this.contentService.body.next('Updated Body Content!'); // Update body content\\n}\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"6rf0akqi4vf\",\"sortIndex\":20,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab completes the journey through reactive programming in Angular, providing a comprehensive understanding of how to build dynamic, responsive user interfaces using Angular services, RxJS, and reactive patterns.\"},{\"blockId\":\"fp176mnnw05\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"5diuz2wdn4c\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Explore the benefits of using services for state management in Angular applications.<br><br></li><li>Discuss the role of BehaviorSubject for representing and updating data streams reactively.<br><br></li><li>Discuss the implications of observable completion on data binding and reactivity in Angular templates.<br><br></li><li>Explore scenarios where of is useful versus the dynamic capabilities required from BehaviorSubject.</li></ul>\"},{\"blockId\":\"peannesmjxk\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"9xwzjil8zg\",\"sortIndex\":19,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Encourage participants to extend the ContentService by adding new data streams and combining them in the component.<br><br></li><li>Discuss strategies for optimizing reactive data flow in larger applications, considering aspects like error handling, loading states, and unsubscribing from streams.<br><br></li><li>Encourage participants to experiment with other RxJS subjects like ReplaySubject and Subject to understand their behaviors and use cases.<br><br></li><li>Discuss strategies for managing and propagating state changes in larger applications, considering performance and complexity.</li></ul>\"}]",
  "__v": 0
},
{
  "_id": "65d272008fb422ed7b83a336",
  "workshopGroupId": "idiomatic-reactive-data-streams",
  "name": "Test",
  "sortId": 5,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-18T21:09:20.696Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Test your knowledge\"},{\"blockId\":\"x6sf1i1jcv\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"What does the async pipe in Angular templates do?\\\",\\\"correctAnswer\\\":\\\"Automatically subscribes to an Observable and returns its latest value\\\",\\\"correctAnswerResponse\\\":\\\"Exactly right! The async pipe automatically subscribes to an Observable and displays its latest value in the template.\\\",\\\"incorrectAnswerResponse\\\":\\\"Not quite. The async pipe is used for automatic subscription to Observables, not for synchronous data fetching or iterating over arrays.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"Synchronously fetches data from a server\\\"},{\\\"value\\\":\\\"Automatically subscribes to an Observable and returns its latest value\\\"},{\\\"value\\\":\\\"Iterates over an array and renders templates for each item\\\"},{\\\"value\\\":\\\"Converts a Promise to an Observable\\\"}]}\"},{\"blockId\":\"h06f452ymeu\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"Which RxJS function creates an Observable that emits the values you provide as arguments and then completes?\\\",\\\"correctAnswer\\\":\\\"of\\\",\\\"correctAnswerResponse\\\":\\\"Correct! The of function emits the provided values once and then completes.\\\",\\\"incorrectAnswerResponse\\\":\\\"Almost, but not quite. The of function is specifically designed to emit any number of provided values once and then complete.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"from\\\"},{\\\"value\\\":\\\"map\\\"},{\\\"value\\\":\\\"of\\\"},{\\\"value\\\":\\\"combineLatest\\\"}]}\"},{\"blockId\":\"fofk1jqzlac\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"Which operator is used to transform the items emitted by an Observable by applying a function to each item?\\\",\\\"correctAnswer\\\":\\\"map\\\",\\\"correctAnswerResponse\\\":\\\"Spot on! The map operator transforms each emitted item by applying a provided function.\\\",\\\"incorrectAnswerResponse\\\":\\\"Not quite. The operator you're looking for to transform emitted items is map.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"filter\\\"},{\\\"value\\\":\\\"map\\\"},{\\\"value\\\":\\\"tap\\\"},{\\\"value\\\":\\\"merge\\\"}]}\"},{\"blockId\":\"rj2584nl8ln\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"What is the primary use of the tap operator in RxJS?\\\",\\\"correctAnswer\\\":\\\"To perform a side effect for every emission on the source Observable\\\",\\\"correctAnswerResponse\\\":\\\"Correct! The tap operator is used for performing side effects, such as logging values, without altering the stream.\\\",\\\"incorrectAnswerResponse\\\":\\\"Close, but tap is actually used for performing side effects without modifying the emitted values.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"To modify the items emitted by an Observable\\\"},{\\\"value\\\":\\\"To perform a side effect for every emission on the source Observable\\\"},{\\\"value\\\":\\\"To retry failed Observables\\\"},{\\\"value\\\":\\\"To combine multiple Observables\\\"}]}\"},{\"blockId\":\"q2wlfwirxik\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"Which RxJS function combines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables?\\\",\\\"correctAnswer\\\":\\\"combineLatest\\\",\\\"correctAnswerResponse\\\":\\\"Exactly! combineLatest combines multiple Observables and emits values calculated from the latest values of each.\\\",\\\"incorrectAnswerResponse\\\":\\\"Not quite. The function that combines multiple Observables and emits values from the latest of each is combineLatest.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"merge\\\"},{\\\"value\\\":\\\"forkJoin\\\"},{\\\"value\\\":\\\"combineLatest\\\"},{\\\"value\\\":\\\"concat\\\"}]}\"},{\"blockId\":\"zzp022kpg3l\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"What is the initial requirement for a BehaviorSubject in RxJS?\\\",\\\"correctAnswer\\\":\\\"It requires an initial value upon creation.\\\",\\\"correctAnswerResponse\\\":\\\"That's right! A BehaviorSubject requires an initial value upon creation to ensure it always has a current value.\\\",\\\"incorrectAnswerResponse\\\":\\\"Almost there. Remember, a BehaviorSubject specifically requires an initial value when it's created.\\\\\\\"\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"It needs to be subscribed to immediately.\\\"},{\\\"value\\\":\\\"It requires an initial value upon creation.\\\"},{\\\"value\\\":\\\"It must combine at least two Observables.\\\"},{\\\"value\\\":\\\"It can only emit strings.\\\"}]}\"},{\"blockId\":\"z633mdaa7nb\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"Why might you use asObservable() when exposing a BehaviorSubject from a service?\\\",\\\"correctAnswer\\\":\\\"To prevent subscribers from emitting new values to the subject\\\",\\\"correctAnswerResponse\\\":\\\"Correct! Using asObservable() prevents external modifications to the BehaviorSubject, maintaining data integrity.\\\\\\\"\\\",\\\"incorrectAnswerResponse\\\":\\\"Not quite. The key reason to use asObservable() is to prevent external parts from directly emitting new values to the BehaviorSubject.\\\\\\\"\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"To increase the performance of data emission\\\"},{\\\"value\\\":\\\"To allow multiple subscribers to modify the subject\\\"},{\\\"value\\\":\\\"To prevent subscribers from emitting new values to the subject\\\"},{\\\"value\\\":\\\"To convert the BehaviorSubject to a Promise\\\"}]}\"},{\"blockId\":\"z3rtw1ikwx\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"In Angular, how can you ensure that a component reacts to updated data emitted by a BehaviorSubject?\\\",\\\"correctAnswer\\\":\\\"By using the async pipe in the template\\\",\\\"correctAnswerResponse\\\":\\\"Exactly! The async pipe in the template subscribes to the BehaviorSubject, ensuring the component reacts to updated data.\\\",\\\"incorrectAnswerResponse\\\":\\\"Close, but the most effective way to ensure a component reacts to updated data from a BehaviorSubject is by using the async pipe in the template.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"By using the ngOnInit lifecycle hook\\\"},{\\\"value\\\":\\\"By manually subscribing to the BehaviorSubject in the component\\\"},{\\\"value\\\":\\\"By using the async pipe in the template\\\"},{\\\"value\\\":\\\"By implementing the OnChanges interface\\\"}]}\"},{\"blockId\":\"pskcnggue1d\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"Which of the following is true about the of function in RxJS?\\\",\\\"correctAnswer\\\":\\\"It creates an Observable that emits the provided values and then completes.\\\",\\\"correctAnswerResponse\\\":\\\"Spot on! The of function emits the provided values once and then completes.\\\\\\\"\\\",\\\"incorrectAnswerResponse\\\":\\\"Not quite right. The of function is used to emit the provided values once before completing, not just the first value.\\\\\\\"\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"It creates an Observable that emits an array of values.\\\"},{\\\"value\\\":\\\"It only emits the first value and then completes.\\\"},{\\\"value\\\":\\\"It creates an Observable that emits the provided values and then completes.\\\"},{\\\"value\\\":\\\"It converts a Promise into an Observable.\\\"}]}\"},{\"blockId\":\"knld3qbujv8\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsQuizBlockMediator\",\"dataClean\":\"{\\\"question\\\":\\\"What is the behavior of the toArray operator in RxJS?\\\",\\\"correctAnswer\\\":\\\"It accumulates all source emissions and emits them as an array when the source completes.\\\",\\\"correctAnswerResponse\\\":\\\"Correct! The toArray operator accumulates all emissions and emits them as an array when the source completes.\\\",\\\"incorrectAnswerResponse\\\":\\\"Almost there. The toArray operator is used to accumulate emissions and emit them as an array, but only when the source Observable completes.\\\",\\\"ratioOptions\\\":[{\\\"value\\\":\\\"It converts an Observable into an array of Observables.\\\"},{\\\"value\\\":\\\"It accumulates all source emissions and emits them as an array when the source completes.\\\"},{\\\"value\\\":\\\"It splits an array emitted by an Observable into individual emissions.\\\"},{\\\"value\\\":\\\"It creates a new Observable for each item in the source Observable.\\\"}]}\"}]",
  "__v": 0
},
{
  "_id": "65d28a298fb422ed7b83a35b",
  "workshopGroupId": "part-2-reactive-streams",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-18T22:52:25.361Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Advanced Reactive Programming with Angular and RxJS\"},{\"blockId\":\"gowau0oqlap\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/2-lab-start.webp\\\",\\\"title\\\":\\\"lab 2 start\\\"}\"},{\"blockId\":\"zrohuk4exdf\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<i>This workshop is an invitation to explore the reactive programming paradigm within the Angular framework, offering both foundational knowledge and advanced techniques. We encourage an inquisitive approach, experimentation, and continuous learning as key components of your development journey.</i><div><br></div><div><b>Reference Material:</b></div><div><ul><li><a href=\\\"https://github.com/Ba5ik7/workshop-reactive-data-streams/tree/2-lab-start\\\">Workshop Lab Repo</a></li></ul></div><div>After cloning the repo checkout the branch 2-lab-start.</div>\"},{\"blockId\":\"ktmkruzrom\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Overview\",\"savedAction\":\"h1\"},{\"blockId\":\"mt9hf57qsf\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Welcome to the advanced module of our reactive programming workshop, where we delve deeper into Angular and RxJS to tackle more complex scenarios involving service integration, dynamic data handling, and sophisticated state management techniques.\"},{\"blockId\":\"zyq1owct9x\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Goals\",\"savedAction\":\"h2\"},{\"blockId\":\"5nt0sugffu2\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Establish a foundational setup for advanced labs, focusing on real-world applications of Angular and RxJS.<br><br></li><li>Introduce mock data and basic service structures to simulate complex data interactions.</li></ul>\"},{\"blockId\":\"bi6rj9fqmon\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Initial Setup\",\"savedAction\":\"h2\"},{\"blockId\":\"mkj3vaxgrn\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"The 2-lab-start branch provides a starting point with an AppComponent, an uninitialized ContentService, and mock data in data.mock.ts. This setup is designed to facilitate hands-on learning of advanced data management and manipulation techniques in Angular applications.\"},{\"blockId\":\"spr2wvfzznn\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Key Concepts\",\"savedAction\":\"h2\"},{\"blockId\":\"lcwkiyc29om\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li><b>Angular Services: </b>Understanding the role of services in Angular for managing data and business logic.<br><br></li><li><b>Mock Data: </b>Utilizing data.mock.ts to simulate complex data structures and relationships.<br><br></li><li><b>Reactive State Management: </b>Preparing for advanced state management patterns using RxJS.</li></ul>\"},{\"blockId\":\"5rmjzecj4lo\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Tasks\",\"savedAction\":\"h1\"},{\"blockId\":\"n0jdbasn96\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Review Initial Files:</b><div><ul><li>Examine the provided AppComponent, ContentService, and data.mock.ts to understand their roles in upcoming labs.</li></ul></div><div><b>Understand Mock Data:</b></div><div><ul><li>Analyze the structures and initial values in data.mock.ts, which will be crucial for simulating data fetching and manipulation.</li></ul></div><div><b>Prepare for Advanced Concepts:</b></div><div><ul><li>Gear up to explore advanced RxJS operators, Angular service integration, and dynamic data manipulation techniques.</li></ul></div>\"},{\"blockId\":\"g0ngzix5gjh\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Upcoming Highlights\",\"savedAction\":\"h2\"},{\"blockId\":\"rxfxsk760u\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li><b>Service Integration:</b> Learn to seamlessly integrate Angular services into components for data fetching and processing.<br><br></li><li><b>Advanced RxJS Techniques:</b> Master complex RxJS operators for sophisticated data stream manipulation.<br><br></li><li><b>Dynamic Data Presentation: </b>Implement dynamic and responsive data presentation strategies within Angular templates.</li></ul>\"}]",
  "__v": 0
},
{
  "_id": "65d29abe8fb422ed7b83a3ac",
  "workshopGroupId": "part-2-reactive-streams",
  "name": "Page 2",
  "sortId": 1,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-19T00:03:10.099Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Fetching and Displaying Data Reactively in Angular\"},{\"blockId\":\"zzhbi99oxrd\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/2.a-lab.webp\\\",\\\"title\\\":\\\"Lab 2\\\"}\"},{\"blockId\":\"74r2040be47\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:&nbsp;</b><span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>To demonstrate fetching data from a service and displaying it in a component using Angular's reactive patterns.</i></span>\"},{\"blockId\":\"rjqfuvuuvfn\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to Reactive Data Fetching\"},{\"blockId\":\"7s578zsv3im\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"This lab introduces reactive data fetching from a service and its display in an Angular component, utilizing RxJS for data stream management and Angular's async pipe for seamless integration into the template.<div><ul><li><b>ContentService:</b> To fetch mock content data reactively.<br><br></li><li><b>RxJS Operators:</b> Specifically map for data transformation.<br><br></li><li><b>Angular Async Pipe:</b> For subscribing to observables within the template.</li></ul></div>\"},{\"blockId\":\"5ra8yrxu6s4\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise:\"},{\"blockId\":\"9w1n41hdxlh\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<div><ul><li>Implement <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">fetchContent$</code> to emit content from <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">data.mock.ts</code> using the of RxJS operator.<br><br></li><li>Use a BehaviorSubject to manage the content state, exposing it as an observable with <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">asObservable()</code>.<br></li></ul></div>\"},{\"blockId\":\"ggtrkn8ttjh\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"Implement the fetchContent$ method in ContentService to return an observable of content data, and update AppComponent to display this data using the async pipe.\"},{\"blockId\":\"rcl5dyr7yph\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"b2ahl78snnc\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"bfbz12dq0gt\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Discuss the benefits of using BehaviorSubject for state management in services.<br><br></li><li>Explore how the async pipe simplifies observable subscriptions in templates.</li></ul>\"},{\"blockId\":\"7zyvrgq1inb\",\"sortIndex\":19,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"d373lq6fznh\",\"sortIndex\":20,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Experiment with different RxJS operators to transform the content data before displaying it.<br><br></li><li>Consider implementing a loading indicator to enhance user experience during data fetch operations.</li></ul>\"},{\"blockId\":\"3qxi4qrem76\",\"sortIndex\":21,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"In this lab, participants will gain hands-on experience with Angular's reactive data handling patterns, from fetching data in a service to displaying it in a component. This foundational knowledge is crucial for building dynamic, responsive applications with Angular and RxJS.\"},{\"blockId\":\"m027xevwdto\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  private _content = new BehaviorSubject<IContent | undefined>(undefined);\\n  content$ = this._content.asObservable();\\n\\n  fetchContent$(): Observable<IContent> {\\n    return of(content).pipe(\\n      tap(content => this._content.next(content))\\n    );\\n  }\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"xvuoc5rtwqj\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"ContentService Setup:\",\"savedAction\":\"h4\"},{\"blockId\":\"3xfha3d6qzc\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Inject <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">ContentService</code>&nbsp;and subscribe to <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">content$</code> to form <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">viewModel$</code>.<br><br></li></ul>\"},{\"blockId\":\"4dtvp18u1ox\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"AppComponent Integration:\",\"savedAction\":\"h4\"},{\"blockId\":\"qwgx6pyy45n\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  viewModel$ = inject(ContentService)\\n    .fetchContent$()\\n    .pipe(map((content) => ({ content })));\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"gf2td11wdv\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"    @if (viewModel$ | async; as vm) {\\n      <h3>{{ vm.content.title }}</h3>\\n      <p>{{ vm.content.body }}</p>\\n      <hr />\\n      <h1>{{ vm.content.welcomeMessage }}</h1>\\n    }\",\"savedAction\":\"xml\"},{\"blockId\":\"vzn57yletk\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Updating the Template:\",\"savedAction\":\"h4\"},{\"blockId\":\"tr88aqwg32g\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Use the async pipe in the template to display content data.</li></ul>\"}]",
  "__v": 0
},
{
  "_id": "65d2a6928fb422ed7b83a3d5",
  "workshopGroupId": "part-2-reactive-streams",
  "name": "Page 3",
  "sortId": 2,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-19T00:53:38.722Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Advanced Reactive Data Handling and Configuration in Angular\"},{\"blockId\":\"vmz1fk6wxgr\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/2.b-lab_a.webp\\\",\\\"title\\\":\\\"2 Lab A \\\"}\"},{\"blockId\":\"x1mnei7btgq\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:</b>&nbsp;<span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>To expand upon basic data fetching by introducing advanced RxJS operators for data transformation and implementing Angular's application initialization process to preload necessary data.</i></span>\"},{\"blockId\":\"uk90qokmvg\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to Angular's APP_INITIALIZER\"},{\"blockId\":\"gs9hbmc4dba\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Building on the foundational skills from the previous lab, this module delves into more sophisticated reactive programming techniques, including transforming data streams with RxJS operators and leveraging Angular's <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">APP_INITIALIZER</code> for data preloading.<div><br></div><div><ul><li><b>RxJS Operators:</b> Specifically filter and map for refining and transforming data streams.<br><br></li><li><b>Angular's APP_INITIALIZER:</b> To preload content data before the application fully initializes, ensuring availability upon component rendering.<br><br></li></ul></div>\"},{\"blockId\":\"igeet3bp2oc\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise:\"},{\"blockId\":\"jzob2cirz2\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Enhance <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">fetchContent$</code> with <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">filter</code> and <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">map</code> operators to process and transform the data stream as needed.<br><br></li><li>Ensure <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">content$</code> emits only defined content objects, filtering out any potential undefined states.<br><br></li></ul>\"},{\"blockId\":\"8mysl40tktq\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"Refine the data fetching mechanism in ContentService and configure the Angular application to preload content data using APP_INITIALIZER.\"},{\"blockId\":\"x0bv32ltl1c\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"mu88yu3k6\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"AppComponent Refinement:\",\"savedAction\":\"h4\"},{\"blockId\":\"1bdx48gveyt\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  viewModel$ = inject(ContentService).content$.pipe(\\n    filter((content): content is IContent  => content !== undefined),\\n    map((content) => ({ content }))\\n  );\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"xm430bvcgp9\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Application Configuration:\",\"savedAction\":\"h4\"},{\"blockId\":\"4f150zcmh6x\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"function initializeAppFactory(contentService: ContentService) {\\n  return () => contentService.fetchContent$();\\n}\\n\\nexport const appConfig: ApplicationConfig = {\\n  providers: [\\n    provideRouter(routes),\\n    {\\n      provide: APP_INITIALIZER,\\n      useFactory: initializeAppFactory,\\n      multi: true,\\n      deps: [ContentService],\\n    },\\n  ],\\n};\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"vgges367r0r\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Implement an initialization function in <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">app.config.ts</code> that invokes <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">ContentService.fetchContent$</code>.<br><br></li><li>Configure <code _ngcontent-ng-c3366709071=\\\"\\\" class=\\\"inline-code-example\\\">APP_INITIALIZER</code> to execute this function at application startup, ensuring content data is loaded and available.<br><br></li></ul>\"},{\"blockId\":\"94hcngi4l5q\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"0pfo3lmffxip\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Explore the impact of data stream transformation on component rendering and user experience.<br><br></li><li>Discuss the benefits and considerations of using APP_INITIALIZER for preloading essential data.<br><br></li></ul>\"},{\"blockId\":\"73ew1e87dj3\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"wnel3ihizv\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Experiment with additional RxJS operators to manipulate data streams further.<br><br></li><li>Consider implementing error handling strategies within the data fetching process to manage failed requests or unavailable data.</li></ul>\"},{\"blockId\":\"sx17iz421a\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab emphasizes the importance of advanced data handling and application configuration in Angular, providing a seamless user experience by ensuring necessary data is preloaded and appropriately transformed for display. Participants will gain valuable insights into optimizing Angular applications for real-world scenarios.\"}]",
  "__v": 0
},
{
  "_id": "65d2b4528fb422ed7b83a404",
  "workshopGroupId": "part-2-reactive-streams",
  "name": "Page 4",
  "sortId": 3,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-19T01:52:18.940Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Complex Data Integration with RxJS and Angular Services\"},{\"blockId\":\"50fkrope0ik\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/2.c-lab.webp\\\",\\\"title\\\":\\\"2.c-lab\\\"}\"},{\"blockId\":\"dh3q07ac8lt\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:</b>&nbsp;<span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>To combine and manipulate data from multiple service streams, integrating user and content data into a single reactive ViewModel within an Angular component.</i></span>\"},{\"blockId\":\"yip7zx7r23o\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to multiple and dependent data streams\"},{\"blockId\":\"htwjnl9zmwj\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"This lab ventures into complex reactive data integration, showcasing the power of RxJS's combineLatest and switchMap to handle multiple, dependent data streams.<div><br></div><div><ul><li><b>RxJS combineLatest:</b> To combine multiple data streams into a single observable.<br><br></li><li><b>RxJS switchMap:</b> To handle dependent data streams and switch to new observables.<br><br></li><li><b>UserService and ContentService:</b> To fetch and combine user information with content data.<br><br></li></ul></div>\"},{\"blockId\":\"5lt64jzh27i\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise:\"},{\"blockId\":\"opz83l5okk\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"Integrate data from UserService and ContentService to create a rich, reactive ViewModel within AppComponent.\"},{\"blockId\":\"n17piq271wc\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Step-by-Step Instructions:\",\"savedAction\":\"h2\"},{\"blockId\":\"o78o8qjc1kp\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Initializing Data Streams in Services:\",\"savedAction\":\"h4\"},{\"blockId\":\"zg0wsjnhhzk\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\" private _userMetadata = new BehaviorSubject<TUserMetadata | undefined>(undefined);\\n userMetadata$ = this._user.asObservable();\\n  \\n fetchUserMetadata$(userPoid: string): Observable<TUserMetadata> {\\n   return of(usersMetadata[userPoid]).pipe(\\n     delay(1500),\\n     tap(user => this._userMetadata.next(user)),\\n   );\\n }\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"3c63b6qbmjm\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>In UserService, create a fetchUser$ method to obtain user data, similarly using tap to push the data into a BehaviorSubject.<br><br></li></ul>\"},{\"blockId\":\"v2b5iaxicbe\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Fetching Dependent Data with switchMap:\",\"savedAction\":\"h4\"},{\"blockId\":\"6owy4q9fmus\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  viewModel$ = combineLatest([\\n    this.contentService.content$,\\n    this.userService.fetchUser$(),\\n  ]).pipe(\\n    switchMap(([content, user]) => {\\n      return this.userService.fetchUserMetadata$(user.poid).pipe(\\n        map(userMetadata => ({ ...content, ...user, ...userMetadata })),\\n      );\\n    })\\n  );\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"faa9aid1hpd\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Use the switchMap operator on the combined observable to wait for the user data to emit, then fetch the user metadata based on the user's poid.<br><br></li><li>Combine the user metadata with the content data in a single object that conforms to the structure expected by the component template.<br><br></li></ul>\"},{\"blockId\":\"req3mii05y\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Displaying Combined Data in the Template:\",\"savedAction\":\"h4\"},{\"blockId\":\"fwxkuh9cr0b\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"    @if (viewModel$ | async; as vm) { \\n      <h3>{{ vm.title }}</h3>\\n      <p>{{ vm.body }}</p>\\n      <hr />\\n      <h1>{{ vm.welcomeMessage }} {{ vm.name }}</h1>\\n      <p>{{ vm.userInfo?.emailLabel }}: {{ vm.email }}</p>\\n    }\",\"savedAction\":\"xml\"},{\"blockId\":\"2sqze61sjxb\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>In the component template, use the Angular async pipe to subscribe to the viewModel$ observable.<br><br></li><li>Display the data using Angular's binding syntax, ensuring all the necessary fields are presented in the template, including conditional rendering for any data that may not be immediately available.<br><br></li></ul>\"},{\"blockId\":\"3067m1ja0r8\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"wegy8m153gc\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>The use of combineLatest for simultaneous data streams vs. sequential data fetching.<br><br></li><li>Benefits of switchMap for dependent data operations and potential pitfalls like subscription cancellation.<br><br></li></ul>\"},{\"blockId\":\"osicnqtyg5p\",\"sortIndex\":19,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"apvm9ph8nj7\",\"sortIndex\":20,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Explore additional RxJS operators to add more advanced functionality to data streams, like catchError and retry.<br><br></li><li>Discuss best practices for error handling in complex data integration scenarios.</li></ul>\"},{\"blockId\":\"3wkggbvseya\",\"sortIndex\":21,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"By the end of this lab, participants will understand how to integrate complex data streams from different services, providing a comprehensive understanding of reactive state management in Angular applications. The skills acquired here will be pivotal for building sophisticated, data-driven user interfaces.\"}]",
  "__v": 0
},
{
  "_id": "65d2ca988fb422ed7b83a416",
  "workshopGroupId": "part-2-reactive-streams",
  "name": "Page 5",
  "sortId": 4,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-19T03:27:20.679Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Streamlining Complex Observables with Angular Services and RxJS Techniques\"},{\"blockId\":\"h40bblfjeqc\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/2.b-lab_b.webp\\\",\\\"title\\\":\\\"2.d-lab\\\"}\"},{\"blockId\":\"ine1e9iovbi\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:</b>&nbsp;<span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>To streamline complex observables in Angular by incorporating model-level (services) transformations, demonstrating efficient data stream handling without unnecessary object copying, and introducing functional programming concepts.</i></span>\"},{\"blockId\":\"vrlpuyglecn\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Expanding on Reactive concepts&nbsp;\"},{\"blockId\":\"6sh481esywi\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"In this lab, we will refine our approach to managing data streams by leveraging service-level transformations with RxJS operators, avoiding redundant object copies, and introducing the concept of pure functions.<div><br></div><div><ul><li><b>Service-Level Transformation:</b> To keep component logic simple and DRY (Don't Repeat Yourself).<br><br></li><li><b>RxJS forkJoin:</b> To combine multiple streams that must complete before emitting.<br><br></li><li><b>RxJS startWith:</b> To provide initial values to observables, highlighting its limitations with forkJoin.<br><br></li><li><b>Pure Functions:</b> To integrate functional programming concepts into data stream processing.</li></ul></div>\"},{\"blockId\":\"326lt83hcdm\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise:\"},{\"blockId\":\"ncapdxe6x0a\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Service-Level Observable Refinement:\",\"savedAction\":\"h4\"},{\"blockId\":\"leo4qpl0uzj\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"userMetadata$ = this.user$.pipe()\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"qco707w924\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Refactor userMetadata$ in UserService to react to user$ emissions and combine user metadata and roles using combineLatest within a switchMap.<br><br></li></ul>\"},{\"blockId\":\"9by5qpdh4o\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"ViewModel Streamlining in AppComponent:\",\"savedAction\":\"h4\"},{\"blockId\":\"ssn0izcdi9\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  viewModel$ = combineLatest([\\n    this.contentService.content$,\\n    this.userService.fetchUser$().pipe(startWith(undefined)),\\n    this.userService.userMetadata$.pipe(startWith(undefined)),\\n  ]).pipe(\\n    map(([user, content, userMetadata]) => ({\\n      ...user, ...content, ...userMetadata\\n    })),\\n    map(vm => ({\\n      ...vm,\\n      ...vm.userInfo,\\n      title: vm.title?.toUpperCase(),\\n      truncate: (str: string, length: number) => str.slice(0, length) + '...',\\n    }))\\n  );\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"xad0cstek3\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Use back-to-back map operations in the viewModel$ stream to apply component-specific transformations such as toUpperCase for the title and a pure function for truncating text.<br><br></li><li>Again, the startWith does not help the viewModel emit a value until the forkJoin in the service has completed all the streams it's joining.</li></ul>\"},{\"blockId\":\"7evwxjnpf72\",\"sortIndex\":21,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"6qhkg12bmlw\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Understanding Observable Completion with forkJoin:\",\"savedAction\":\"h4\"},{\"blockId\":\"z83rlm76yss\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  userMetadata$ = this.user$.pipe(\\n    filter((user): user is NonNullable<typeof user> => !!user),\\n    switchMap((user) => {\\n      return forkJoin({\\n        userMetadata: of(usersMetadata[user.poid]),\\n        userRoles: this.fetchUserRoles$(user),\\n      });\\n    }),\\n    map(({ userMetadata, userRoles }) => ({ ...userMetadata, ...userRoles })),\\n    tap((userMetadataAndRoles) => this._userMetadata.next(userMetadataAndRoles))\\n  );\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"0cxnh3tgjs3g\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Recognize how forkJoin requires all input observables to complete, noting that startWith will not cause the stream to continue emitting values.<br><br></li></ul>\"},{\"blockId\":\"evrluxbjzh\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Data Type Marshalling:\",\"savedAction\":\"h4\"},{\"blockId\":\"22epn7rzasa\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"type TUserMetadata = { name: string; email: string };\\ntype TUserRoles = { roles: string[] };\\ntype TUserMetadataAndRoles = TUserMetadata & TUserRoles;\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"0hfqkeb6tyge\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Create TypeScript types to support data marshaling and ensure type safety throughout the data handling process.<br><br></li></ul>\"},{\"blockId\":\"pb8xcfxn7y\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Updating the Template:\",\"savedAction\":\"h4\"},{\"blockId\":\"ho6zi44wjii\",\"sortIndex\":19,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"    @if (viewModel$ | async; as vm) { \\n      <h3>{{ vm.title }}</h3>\\n      <p>{{ vm.truncate(vm.body ?? '', 12) }}</p>\\n      <hr />\\n      <h1>{{ vm.welcomeMessage }} {{ vm.name }}</h1>\\n      <p>{{ vm.emailLabel }}: {{ vm.email }}</p>\\n\\n      <p>{{ vm.rolesLabel }}: \\n      @for (role of vm.roles; track $index) {\\n        {{ role }}\\n      }\\n      </p>\\n    }\\n    <router-outlet></router-outlet>\",\"savedAction\":\"xml\"},{\"blockId\":\"b4b48rxzamh\",\"sortIndex\":20,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Note that truncate is a \\\"pure function\\\". However, Angular does not know that and will invoke that method during change detection. Using pipes in next lab.</li></ul><br>\"},{\"blockId\":\"056umkw4hcnx\",\"sortIndex\":22,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Analyze how higher-order functions in JavaScript differ from higher-order operators in RxJS regarding object copying and memory management.<br><br></li><li>Discuss the concept of pure functions and their benefits in programming, particularly in reactive programming with RxJS.<br><br></li></ul>\"},{\"blockId\":\"ba0fpb32yeg\",\"sortIndex\":24,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Consider the application of pure functions within RxJS operators to further refine and manipulate data streams.<br><br></li><li>Prepare for the introduction of Angular pipes in the next lab, contrasting their use with in-stream transformations.<br><br></li></ul>\"},{\"blockId\":\"ljjj6ssh15\",\"sortIndex\":23,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"brhryc0prp\",\"sortIndex\":25,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab encourages a thoughtful approach to observable management in Angular, emphasizing efficient data stream transformations and the integration of functional programming principles. By the end of this lab, participants will be equipped with strategies for crafting streamlined and performant reactive data flows.\"}]",
  "__v": 0
},
{
  "_id": "65d2debc8fb422ed7b83a45f",
  "workshopGroupId": "part-2-reactive-streams",
  "name": "Page 6",
  "sortId": 5,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-19T04:53:16.319Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Refining Angular Views with Pipes, Loading Techniques, and RxJS Error Handling\"},{\"blockId\":\"s504r002jym\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/2-lab-complete_a.webp\\\",\\\"title\\\":\\\"2-lab-complete\\\"}\"},{\"blockId\":\"7fh60ikrgm\",\"sortIndex\":2,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"<b>Objective:&nbsp;</b><span style=\\\"color: var(--mat-sidenav-content-text-color); letter-spacing: 0.0178571em;\\\"><i>To refine the UI/UX in an Angular application by utilizing built-in pipes for data transformation, implementing conditional loading states in templates, flattening the ViewModel for simpler template logic, and introducing robust error handling strategies with RxJS.</i></span>\"},{\"blockId\":\"iha7ypido0g\",\"sortIndex\":3,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Introduction to Error Handling\"},{\"blockId\":\"ybhgsoh9bl\",\"sortIndex\":4,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"This lab concludes our advanced Angular series by integrating built-in Angular pipes, demonstrating their 'pure' transformation capabilities, showcasing conditional rendering techniques for loading states, and adopting comprehensive RxJS error handling strategies within our observables pipeline.<div><ul><li><b>Angular Built-In Pipes:</b> For 'pure' data transformations directly within templates.<br><br></li><li><b>Conditional Loading Techniques:</b> Utilizing the *ngIf; else syntax for cleaner template conditional logic.<br><br></li><li><b>ViewModel Streamlining:</b> Flattening the ViewModel to avoid optional chaining and simplify template expressions.<br><br></li><li><b>RxJS Error Handling:</b> Implementing different strategies for error handling within observable chains.</li></ul></div>\"},{\"blockId\":\"w6w1p4kyk0i\",\"sortIndex\":5,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Hands-on Exercise:\"},{\"blockId\":\"1v9h56abo2li\",\"sortIndex\":6,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"Enhance the user interface with pure pipes for data transformation, introduce conditional rendering for loading states, simplify the ViewModel, and practice various RxJS error handling techniques.\"},{\"blockId\":\"l8jn999444p\",\"sortIndex\":7,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Integrating Angular Pipes:\",\"savedAction\":\"h4\"},{\"blockId\":\"8agmlg46goq\",\"sortIndex\":8,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"<h3>{{ vm.title | uppercase }}</h3>\\n<p>{{ vm.body | slice: 0 : 12  }}...</p>\",\"savedAction\":\"xml\"},{\"blockId\":\"xborgvbusj\",\"sortIndex\":9,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Replace in-stream transformations with Angular built-in pipes like uppercase, slice, and a custom 'truncate' pipe to demonstrate pure transformations in the template.<br><br></li><li>Angular Built in Pipes: <a href=\\\"https://angular.io/api/common/CommonModule#pipes\\\">https://angular.io/api/common/CommonModule#pipes</a><br><br></li></ul>\"},{\"blockId\":\"yw8hb7f0t9e\",\"sortIndex\":10,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Implementing Conditional Loading States:\",\"savedAction\":\"h4\"},{\"blockId\":\"0ewl05v8nfku\",\"sortIndex\":11,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"<h1>{{ vm.welcomeMessage }} {{ vm.name ?? 'I Should be a Pipe' }}</h1>\\n<p>{{ vm.emailLabel }}: {{ vm.email ?? 'I Should be a Pipe' }}</p>\",\"savedAction\":\"xml\"},{\"blockId\":\"oa23awszvm\",\"sortIndex\":12,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Use Angular's *ngIf; else syntax in the template to switch between the content display and loading placeholders, providing immediate feedback to users.<br><br></li><li>These should be pipes will export more on the subject in the future. <i>\\\"Maybe, it returns a loading SVG\\\"</i>. Remember Pipes can be \\\"Prue\\\".<br><br></li></ul>\"},{\"blockId\":\"gm387p0xit6\",\"sortIndex\":13,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Streamlining the ViewModel:\",\"savedAction\":\"h4\"},{\"blockId\":\"0hum9fqqrhes\",\"sortIndex\":14,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"map(([content, user, userMetadata]) => ({\\n  ...user, \\n  ...content, \\n  ...userMetadata,\\n  ...content?.userInfo,\\n})),\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"1ss7shc89c5\",\"sortIndex\":15,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Flatten the ViewModel within the observable chain to allow for direct property access in the template, eliminating the need for complex optional chaining.</li></ul>\"},{\"blockId\":\"kp1ikkiuh1\",\"sortIndex\":27,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Discussion Points:\",\"savedAction\":\"h2\"},{\"blockId\":\"t6stujao0l\",\"sortIndex\":28,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>The advantages of using Angular pipes for transformations, and when to consider them 'pure'.<br><br></li><li>Strategies for providing user feedback during data fetching, such as loading indicators.<br><br></li></ul>\"},{\"blockId\":\"gxlwb6dg8u7\",\"sortIndex\":29,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Further Exploration:\",\"savedAction\":\"h2\"},{\"blockId\":\"8n24lbfmgvu\",\"sortIndex\":30,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Create custom Angular pipes for complex data transformations.<br><br></li><li>Practice advanced error handling patterns in RxJS and their implications for user experience.<br><br></li></ul>\"},{\"blockId\":\"0mkt1xyonjj\",\"sortIndex\":31,\"componentInstanceName\":\"NgxEditorjsBlockquotesBlockMediator\",\"dataClean\":\"This lab brings together a full suite of advanced Angular features to create a polished, user-friendly application interface. By integrating Angular pipes, conditional rendering, ViewModel streamlining, and error handling, participants will have a comprehensive toolkit for building resilient and maintainable reactive Angular applications.\"},{\"blockId\":\"0ifp6zx4slj8\",\"sortIndex\":16,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Adopting RxJS Error Handling Strategies:\",\"savedAction\":\"h2\"},{\"blockId\":\"033ty2mr2h3t\",\"sortIndex\":26,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"\"},{\"blockId\":\"9emvuexay75\",\"sortIndex\":17,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Catch and Replace Strategy:\",\"savedAction\":\"h4\"},{\"blockId\":\"07sf8m35ofew\",\"sortIndex\":18,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"fetchUserRoles$(user: IUser): Observable<TUserRoles> {\\n  return of(userRoles[user.poid]).pipe(\\n    // tap(() => {\\n    //   throw new Error('Error fetching user roles');\\n    // }),\\n    delay(3000),\\n    map((userRoles) => ({ roles: userRoles.roles })),\\n    catchError((error) => {\\n      console.warn('Error fetching user', error);\\n      return of({ roles: ['Error Getting Roles'] });\\n    })\\n  );\\n}\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"jcz3jo91r1k\",\"sortIndex\":19,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>Utilize the catchError operator to gracefully handle errors within your observable streams. When an error occurs, instead of breaking the stream, catchError allows you to replace the errored observable with another observable. This is particularly useful in scenarios where you want to provide a fallback value or an alternative data stream in case of an error.<br><br></li><li><b>Example Usage: </b>If fetching user details fails, you might switch to an observable emitting default user detail, ensuring the application continues to function smoothly.<br><br></li></ul>\"},{\"blockId\":\"77f6y84zqhq\",\"sortIndex\":20,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Catch and Rethrow Strategy:\",\"savedAction\":\"h4\"},{\"blockId\":\"9i1tza60mba\",\"sortIndex\":22,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>In situations where you need to handle errors but also want to ensure they are not swallowed silently, the throwError function can be used in conjunction with catchError. This strategy allows you to perform some error handling, such as logging the error, and then rethrow it to be handled further up the stream or by a global error handler.<br><br></li><li><b>Example Usage:</b> After catching an error in a data fetching operation, log the error for debugging purposes, then use throwError to rethrow the error, allowing it to propagate to a global error handler or another part of the application for more specialized handling.</li></ul>\"},{\"blockId\":\"v3gxhw90xyg\",\"sortIndex\":21,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  userMetadata$ = this.user$.pipe(\\n    // tap(() => {\\n    //   throw new Error('Error fetching user metadata');\\n    // }),\\n    filter((user): user is NonNullable<typeof user> => !!user),\\n    switchMap((user) => {\\n      return combineLatest({\\n        userMetadata: of(usersMetadata[user.poid]),\\n        userRoles: this.fetchUserRoles$(user).pipe(startWith(undefined)),\\n      });\\n    }),\\n    map(({ userMetadata, userRoles }) => ({ ...userMetadata, ...userRoles })),\\n    tap((userMetadataAndRoles) => this._userMetadata.next(userMetadataAndRoles)),\\n    catchError((error) => {\\n      console.warn('Error fetching user metadata', error);\\n      return throwError(() => new Error('Pass the error along'));\\n    })\\n  );\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"gvypgiax44\",\"sortIndex\":23,\"componentInstanceName\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Strategic Placement of catchError:\",\"savedAction\":\"h4\"},{\"blockId\":\"gigrid4j82\",\"sortIndex\":24,\"componentInstanceName\":\"NgxEditorjsCodeBlockMediator\",\"dataClean\":\"  fetchUser$(): Observable<IUser> {\\n    return of(user).pipe(\\n      // tap(() => {\\n      //   throw new Error('Error fetching user');\\n      // }),\\n      delay(1500),\\n      tap((user) => this._user.next(user)),\\n      catchError((error) => {\\n        console.warn('Error fetching user', error);\\n        throw error;\\n      })\\n    );\\n  }\",\"savedAction\":\"text/typescript\"},{\"blockId\":\"03kvn6a124x2\",\"sortIndex\":25,\"componentInstanceName\":\"NgxEditorjsParagraphBlockMediator\",\"dataClean\":\"<ul><li>The placement of catchError within your observable chain is crucial. Placing it closer to the source of the observable allows for more granular error handling, potentially recovering from errors without affecting the rest of the stream. Conversely, placing catchError towards the end of the chain provides a more generalized error handling approach, treating all errors in the chain uniformly.<br><br></li><li><b>Example Usage: </b>To handle errors specific to data fetching, place catchError immediately after the fetching operation. For more general error handling, such as displaying a global error message, place catchError at the end of the observable chain.</li></ul>\"}]",
  "__v": 0
},
{
  "_id": "65d39eaa8fb422ed7b83a55a",
  "workshopGroupId": "part-3-reactive-streams",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-19T18:32:10.328Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Magical Workshop&nbsp;🪄 Coming Soon...\"}]",
  "__v": 0
},
{
  "_id": "65d40fb18fb422ed7b83a5f0",
  "workshopGroupId": "part-1-data-streams",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T02:34:25.084Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"<i>Isomorphic!&nbsp;</i>Idiomatic Reactive Data Streams with NestJs\"},{\"blockId\":\"43s2folig7m\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/nestjs_1_thumb_b.webp\\\",\\\"title\\\":\\\"NestJs Reactive Streams\\\"}\"}]",
  "__v": 0
},
{
  "_id": "65d41af08fb422ed7b83a610",
  "workshopGroupId": "easy-as-123",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T03:22:24.760Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Magical Workshop&nbsp;🪄 Coming Soon...\"},{\"blockId\":\"x0pyufd8gqc\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/rxjs_1_thumb_b.webp\\\",\\\"title\\\":\\\"RxJS 1\\\"}\"}]",
  "__v": 0
},
{
  "_id": "65d41bcb8fb422ed7b83a61a",
  "workshopGroupId": "hot-vs-cold",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T03:26:03.549Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"dataClean\":\"Magical Workshop&nbsp;🪄 Coming Soon...\"},{\"blockId\":\"vrx9d5yf1tc\",\"sortIndex\":1,\"componentInstanceName\":\"NgxEditorjsImageBlockMediator\",\"dataClean\":\"{\\\"url\\\":\\\"https://ngx-workshop.io/assets/img/rxjs_2_thumb_b.webp\\\",\\\"title\\\":\\\"Hor vs Cold\\\"}\"}]",
  "__v": 0
},
{
  "_id": "65d41f1a8fb422ed7b83a638",
  "workshopGroupId": "route-reuse-strategy",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T03:40:10.601Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"name\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Create a Magical Workshop&nbsp;🪄\"}]",
  "__v": 0
},
{
  "_id": "65d42c9f8fb422ed7b83a641",
  "workshopGroupId": "getting-started",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T04:37:51.368Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"name\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Create a Magical Workshop&nbsp;🪄\"}]",
  "__v": 0
},
{
  "_id": "65d42d648fb422ed7b83a665",
  "workshopGroupId": "view-container-ref",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T04:41:08.786Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"name\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Create a Magical Workshop&nbsp;🪄\"}]",
  "__v": 0
},
{
  "_id": "65d42de68fb422ed7b83a66b",
  "workshopGroupId": "reactive-forms",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T04:43:18.276Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"name\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Create a Magical Workshop&nbsp;🪄\"}]",
  "__v": 0
},
{
  "_id": "65d42e088fb422ed7b83a671",
  "workshopGroupId": "control-value-accessor",
  "name": "Page",
  "sortId": 0,
  "pageType": "PAGE",
  "lastUpdated": {
    "$date": "2024-02-20T04:43:52.760Z"
  },
  "html": "[{\"blockId\":\"eftkta822ke\",\"sortIndex\":0,\"name\":\"NgxEditorjsHeaderBlockMediator\",\"dataClean\":\"Create a Magical Workshop&nbsp;🪄\"}]",
  "__v": 0
}]